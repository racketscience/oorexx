/*----------------------------------------------------------------------------*/
/*                                                                            */
/* Copyright (c) 1995, 2004 IBM Corporation. All rights reserved.             */
/* Copyright (c) 2005-2006 Rexx Language Association. All rights reserved.    */
/*                                                                            */
/* This program and the accompanying materials are made available under       */
/* the terms of the Common Public License v1.0 which accompanies this         */
/* distribution. A copy is also available at the following address:           */
/* http://www.oorexx.org/license.html                          */
/*                                                                            */
/* Redistribution and use in source and binary forms, with or                 */
/* without modification, are permitted provided that the following            */
/* conditions are met:                                                        */
/*                                                                            */
/* Redistributions of source code must retain the above copyright             */
/* notice, this list of conditions and the following disclaimer.              */
/* Redistributions in binary form must reproduce the above copyright          */
/* notice, this list of conditions and the following disclaimer in            */
/* the documentation and/or other materials provided with the distribution.   */
/*                                                                            */
/* Neither the name of Rexx Language Association nor the names                */
/* of its contributors may be used to endorse or promote products             */
/* derived from this software without specific prior written permission.      */
/*                                                                            */
/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        */
/* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT          */
/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS          */
/* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   */
/* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,      */
/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   */
/* TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,        */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY     */
/* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING    */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         */
/* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               */
/*                                                                            */
/*----------------------------------------------------------------------------*/
/******************************************************************************/
/* REXX Macros                                                  oryxb.orx     */
/*                                                                            */
/* Create the Rexx base (Object/Class) classes.                               */
/*                                                                            */
/******************************************************************************/

use arg kernel_methods

say ('creating the system specific methods ...')
                                       /* name the common objects           */
.environment~objectname = "The environment"
.kernel~objectname = "The kernel directory"
.nil~objectname = "The NIL object"

say 'Adding appendAll method to ARRAY, LIST and QUEUE'
appendMethods = .table~new
appendMethods~put(.methods~ordered_appendall, 'APPENDALL')

/*
.array~inherit(.OrderedCollection);
.list~inherit(.OrderedCollection);
.queue~inherit(.OrderedCollection);
*/

.array~!define_methods(appendMethods)
.list~!define_methods(appendMethods)
.queue~!define_methods(appendMethods)

say 'Adding putAll methods to TABLE, DIRECTORY, and RELATION'
putMethods = .table~new
putMethods~put(.methods~collection_putall, 'PUTALL')

say ('Adding setlike methods to table, relation, and directory')
set_methods = .table~new               /* get a table directory             */
                                       /* add the single item methods       */
set_methods~put(.methods~single_union,        'UNION')
set_methods~put(.methods~single_subset,       'SUBSET')
set_methods~put(.methods~single_intersection, 'INTERSECTION')
set_methods~put(.methods~single_difference,   'DIFFERENCE')
set_methods~put(.methods~single_xor,          'XOR')
.table~!define_methods(set_methods)    /* add to both table and directory   */
.directory~!define_methods(set_methods)

                                       /* now repeat with the many item ones*/
set_methods~put(.methods~many_union,        'UNION')
set_methods~put(.methods~many_subset,       'SUBSET')
set_methods~put(.methods~many_intersection, 'INTERSECTION')
set_methods~put(.methods~many_difference,   'DIFFERENCE')
set_methods~put(.methods~many_xor,          'XOR')
.relation~!define_methods(set_methods) /* add to relation                   */

.collection~!rexxdefined
.orderedcollection~!rexxdefined
.mapcollection~!rexxdefined

.environment~setentry('COLLECTION', .collection)
.environment~setentry('ORDEREDCOLLECTION', .orderedcollection)
.environment~setentry('MAPCOLLECTION', .mapcollection)
.environment~setentry('SETCOLLECTION', .mapcollection)

/* Call the system dependant routine to define addition methods */
systemMethods = 'SystemMethods.orx'()           /* case sensitive           */

say ('creating .!server and defining its instance methods')
server = .object~subclass('server')
server_mdict = .table~new

server_mdict~put(.methods~server_init, 'INIT')
server_mdict~put(kernel_methods['RUN_PROGRAM'], 'RUN_PROGRAM')
server_mdict~put(kernel_methods['CALL_PROGRAM'], 'CALL_PROGRAM')
server_mdict~put(kernel_methods['CALL_STRING'], 'CALL_STRING')
server_mdict~put(.methods~server_save_result, 'SAVE_RESULT')

server~!define_methods(server_mdict)
server~!rexxdefined                     /* Mark as unchangeable          */
.environment~setentry('!server', server)

/* make references to .local return the local environment */
.environment~setmethod('LOCAL',kernel_methods['LOCAL'])

/* load the system objects */
call 'SystemObjects.orx'                           /* all lower case for Unix  @MAE002M */

call 'PlatformObjects.orx'                   -- now load platform-specific builtin classes

say ('Base objects created')

exit

/* ********************************************************************************************* */
/* ********************************************************************************************* */
/* *** Start of unattached METHOD definitions for the various enhanced objects created above *** */
/* ********************************************************************************************* */
/* ********************************************************************************************* */

/*============================================================================*/
/*    S I N G L E I T E M   M E T H O D S      (for Directory, and Table)     */
/*============================================================================*/

/*****************************************/
/* DIFFERENCE method                     */
/*****************************************/
::METHOD single_difference             /* take the difference of collections*/
use strict arg other                   /* get the companion object          */

signal on nomethod                     /* trap unknown method calls         */

new = self~copy                        /* make a new collection             */
do index over other                    /* loop over the other collection    */
  new~remove(index)                    /* "subtract" this item              */
end

return new                             /* return the difference collection  */

nomethod:                              /* unknown method sent               */
      -- an unknown method is an argument problem.  report it as such.
  raise syntax 93.948 array(1, "Collection")

/*****************************************/
/* XOR        method                     */
/*****************************************/
::METHOD single_xor                    /* take the exclusive or of a set    */
use strict arg other                   /* get the companion object          */

signal on nomethod                     /* trap unknown method calls         */

new = self~copy
if other~hasmethod("union") then       /* is other non-primitive collection?*/
do index over other                    /* do for directory, table, relation */
  if self~hasindex(index) then         /* in this collection?               */
    new~remove(index)                  /* remove from the reference set     */
  else
    new~put(other[index], index)       /* add non-located                   */
end
else do index over other               /* do it for array, queue, and list  */
  if self~hasindex(index) then         /* in this collection?               */
    new~remove(index)                  /* remove from the reference set     */
  else
    new~put(index, index)              /* add non-located                   */
end

return new                             /* return the XOR collection         */

nomethod:
      -- an unknown method is an argument problem.  report it as such.
  raise syntax 93.948 array(1, "Collection")

/*****************************************/
/* INTERSECTION  method                  */
/*****************************************/
::METHOD single_intersection           /* take the intersection of sets     */
use strict arg other                   /* get the other collection          */

signal on nomethod                     /* trap unknown method calls         */

new = self~class~new                   /* create a new collection           */
do index over other                    /* loop over the other collection    */
  if self~hasindex(index) then         /* in this collection?               */
    new~put(self[index], index)        /* add to the intersection collection*/
end

return new                             /* return the result collection      */

nomethod:
      -- an unknown method is an argument problem.  report it as such.
  raise syntax 93.948 array(1, "Collection")

/*****************************************/
/* UNION         method                  */
/*****************************************/
::METHOD single_union                  /* take the union of sets            */
use strict arg other                   /* get the other collection          */

signal on nomethod                     /* trap unknown method calls         */

new = self~copy                        /* copy the collection               */
if other~hasmethod("union") then       /* is other non-primitive collection?*/
do index over other                    /* do for directory, table, relation */
  if \new~hasindex(index) then         /* not already there?                */
    new~put(other[index], index)       /* add to the target collection      */
end
else do index over other               /* do it for array, queue, and list  */
  if \new~hasindex(index) then         /* not already there?                */
    new~put(index, index)              /* add to the target collection      */
end

return new                             /* return the target collection      */

nomethod:
      -- an unknown method is an argument problem.  report it as such.
  raise syntax 93.948 array(1, "Collection")

/*****************************************/
/* SUBSET        method                  */
/*****************************************/
::METHOD single_subset                 /* do we have a subset?              */
use strict arg other                   /* get the other collection          */

signal on nomethod                     /* trap unknown method calls         */

if other~hasmethod("union") then       /* is other non-primitive collection?*/
do index over self                     /* do for directory, table, relation */
  if \other~hasindex(index) then       /* not in the other collection?      */
    return .false                      /* return FALSE (no subset)          */
end
else do                                /* do it for array, queue, and list  */
  object = self~copy                   /* make a copy of this object        */
  do index over other                  /* loop over the other collection    */
    object~remove(index)               /* remove from the target collection */
  end
  return 0=object~items                /* if nothing left -> proper subset  */
end

return .true                           /* collection is a proper subset     */

nomethod:
      -- an unknown method is an argument problem.  report it as such.
  raise syntax 93.948 array(1, "Collection")

/*============================================================================*/
/*    M A N Y I T E M       M I X I N         (for Relation)                  */
/*============================================================================*/

/*****************************************/
/* UNION         method                  */
/*****************************************/
::METHOD many_union
use strict arg other                   /* get the other collection          */

signal on nomethod                     /* trap unknown method requests      */

new = self~copy                        /* copy ourself                      */
if other~hasmethod("union") then       /* is other non-primitive collection?*/
do                                     /* do for directory, table, relation */
  supplier = other~supplier            /* get a supplier                    */
  do while supplier~available          /* loop over the other collection    */
                                       /* add to the target collection      */
    new~put(supplier~item, supplier~index)
    supplier~next                      /* step to the next item             */
  end
end
else do index over other               /* do it for array, queue, and list  */
  new~put(index, index)                /* add to the target collection      */
end
return new                             /* return the union collection       */

nomethod:
      -- an unknown method is an argument problem.  report it as such.
  raise syntax 93.948 array(1, "Collection")


/*****************************************/
/* DIFFERENCE    method                  */
/*****************************************/
::METHOD many_difference               /* take the difference of collections*/
use strict arg other                   /* get the companion object          */

signal on nomethod                     /* trap unknown method requests      */

new = self~copy                        /* make a new set                    */
if other~hasmethod("union") then       /* is other non-primitive collection?*/
do                                     /* do for directory, table, relation */
  supplier = other~supplier            /* get an object supplier            */
  do while supplier~available          /* loop over the other collection    */
                                       /* remove from the target collection */
    new~removeitem(supplier~item, supplier~index)
    supplier~next                      /* step to the next item             */
  end
end
else do index over other               /* do it for array, queue, and list  */
  new~removeitem(index, index)         /* remove from the target collection */
end
return new                             /* return the difference collection  */

nomethod:
      -- an unknown method is an argument problem.  report it as such.
  raise syntax 93.948 array(1, "Collection")


/*****************************************/
/* XOR           method                  */
/*****************************************/
::METHOD many_xor                      /* take the exclusive or of a set    */
use strict arg other                   /* get the companion object          */

signal on nomethod                     /* trap unknown method calls         */

new = self~copy
catcher = self~class~new               /* create a new empty one            */
if other~hasmethod("union") then       /* is other non-primitive collection?*/
do                                     /* do for directory, table, relation */
  supplier = other~supplier            /* get an object supplier            */
  do while supplier~available          /* loop over the other collection    */
    index = supplier~index             /* get the index                     */
    value = supplier~item              /* and the value                     */
    if new~hasitem(value, index) then  /* in the reference collection?      */
      new~removeitem(value, index)     /* remove from the reference set     */
    else
      catcher~put(value, index)        /* add non-located to the catcher    */
    supplier~next                      /* step to the next item             */
  end
end
else do index over other               /* do it for array, queue, and list  */
  if new~hasitem(index, index) then    /* in the other collection?          */
    new~removeitem(index, index)       /* remove from the reference set     */
  else
    catcher~put(index, index)          /* add non-located to the catcher    */
end
return new~union(catcher)              /* now remerge these collections     */

nomethod:
      -- an unknown method is an argument problem.  report it as such.
  raise syntax 93.948 array(1, "Collection")


/*****************************************/
/* INTERSECTION  method                  */
/*****************************************/
::METHOD many_intersection             /* take the intersection of sets     */
use strict arg other                   /* get the other collection          */

signal on nomethod                     /* trap unknown method calls         */

new = self~class~new                   /* start with a new collection       */
object = self~copy                     /* copy the target collection        */
if other~hasmethod("union") then       /* is other non-primitive collection?*/
do                                     /* do for directory, table, relation */
  supplier = other~supplier            /* get an other supplier             */
  do while supplier~available          /* loop over the other collection    */
    index = supplier~index             /* get the index                     */
    value = supplier~item              /* and the value                     */
                                       /* in the reference collection?      */
    if object~hasitem(value, index) then do
      new~put(value, index)            /* add to the new collection         */
      object~removeitem(value, index)  /* remove from the reference set     */
    end
    supplier~next                      /* step to the next item             */
  end
end
else do index over other               /* do it for array, queue, and list  */
                                       /* in the reference collection?      */
  if object~hasitem(index, index) then do
    new~put(index, index)              /* add to the new collection         */
    object~removeitem(index, index)    /* remove from the reference set     */
  end
end
return new                             /* return the new collection         */

nomethod:
      -- an unknown method is an argument problem.  report it as such.
  raise syntax 93.948 array(1, "Collection")


/*****************************************/
/* SUBSET        method                  */
/*****************************************/
::METHOD many_subset                   /* do we have a subset?              */
use strict arg other                   /* get the other collection          */

signal on nomethod                     /* trap unknown method calls         */

object = self~copy                     /* make a copy of this object        */
if other~hasmethod("union") then       /* is other non-primitive collection?*/
do                                     /* do for directory, table, relation */
  supplier = other~supplier            /* get an other supplier             */
  do while supplier~available          /* loop over the other collection    */
                                       /* remove from target collection     */
    object~removeitem(supplier~item, supplier~index)
    supplier~next                      /* step to the next item             */
  end
end
else do index over other               /* do it for array, queue, and list  */
  object~removeitem(index, index)      /* remove from the target collection */
end
return 0=object~items                  /* if nothing left -> proper subset  */

nomethod:
      -- an unknown method is an argument problem.  report it as such.
  raise syntax 93.948 array(1, "Collection")



/*****************************************/
/* APPENDALL     method                  */
/*****************************************/
::method ordered_appendall
  use strict arg other

  signal on nomethod

  do item over other~allItems            /* loop over the other collection    */
    self~append(item)                    -- appending the item
  end

nomethod:
      -- an unknown method is an argument problem.  report it as such.
  raise syntax 93.948 array(1, "Collection")


/*****************************************/
/* PUTALL        method                  */
/*****************************************/
::method collection_putall
  use strict arg other
  signal on nomethod

  supplier = other~supplier              /* get an other supplier             */
  do while supplier~available            /* loop over the other collection    */
    self~put(supplier~item, supplier~index)   -- putting the item using the same index
    supplier~next
  end

nomethod:
      -- an unknown method is an argument problem.  report it as such.
  raise syntax 93.948 array(1, "Collection")


::METHOD server_save_result
 /* anchor a passed out result */
  expose savedResults
  use arg resultObj
  savedResults[resultObj] = resultObj


::METHOD server_init
 /* initialize a server */
  expose localenv savedResults

  savedResults = .table~new
  .local~setentry('LOCALSERVER',self)

 /* set system objects in the local environment */
  .local~setentry('STDIN',.stream~new('STDIN')~~command('open nobuffer'))
  .local~setentry('INPUT',.monitor~new(.stdin))
  .local~setentry('STDOUT',.stream~new('STDOUT')~~command('open nobuffer'))
  .local~setentry('OUTPUT',.monitor~new(.stdout))
  .local~setentry('STDERR',.stream~new('STDERR')~~command('open nobuffer'))
  .local~setentry('ERROR', .monitor~new(.stderr))

  .local~setentry('STDQUE',.rx_queue~new~~set('SESSION'))

-- tagging classes for Collection class types
::CLASS Collection MIXINCLASS Object
::CLASS OrderedCollection MIXINCLASS Collection
::CLASS MapCollection MIXINCLASS Collection
::CLASS SetCollection MIXINCLASS Collection
